<?php 
// $Id$

define('MIGRATE_ACCESS_BASIC', 'basic migration tools');
define('MIGRATE_ACCESS_ADVANCED', 'advanced migration tools');

define('MIGRATE_MESSAGE_ERROR', 1);
define('MIGRATE_MESSAGE_WARNING', 2);
define('MIGRATE_MESSAGE_NOTICE', 3);
define('MIGRATE_MESSAGE_INFORMATIONAL', 4);

/**
 * @file
 * This module provides tools at "administer >> content >> migrate"
 * for analyzing data from various sources and importing them into Drupal tables.
 * 
 * @TODO:
 * PostGres support (MySQL is assumed in several places)
 * Robustness - check to make sure all prerequisites are done (e.g., table view should
 *  not be available until Analyze is done)
 * The analysis tool allows setting a multi-column PK for the import file, but everything
 *  else assumes a single column. Dealing with this is deferred until/unless we have a 
 *  situation requiring a multi-column PK.
 */

/**
 * Implementation of hook_migrate_init() - initialize support for the builtin sources
 * and destinations.
 * 
 * @return
 *    An array of descriptors for the source and destination types we support,
 */
function migrate_migrate_init() {
  $path = drupal_get_path('module', 'migrate') . '/migrate_destinations.inc';
  include_once($path);
  return array(
    'destination' => array(
      'comment' => t('Comment'),
      'node' => t('Node'),
      'user' => t('User'),
    ),
  );
}

/**
 * Call a migrate hook
 */
function migrate_invoke_all($kind, $hook, $type = NULL) {
  // First time in initialize the modules implementing hooks, and get
  // info on what sources and destinations they support
  static $supported = array();
  if (empty($supported)) {
    $supported = module_invoke_all('migrate_init');
  }
  $args = func_get_args();
  $hookfunc = "migrate_$kind"."_$hook";
  if (isset($type)) {
    $hookfunc .= "_$type";
    unset($args[2]);
  }
  unset($args[1]);
  unset($args[0]);
  $return = array();
  $modulelist = module_implements($hookfunc);
  foreach ($modulelist as $module) {
    $function = $module .'_'. $hookfunc;
    $result = call_user_func_array($function, $args);
    if (isset($result) && is_array($result)) {
      $return = array_merge_recursive($return, $result);
    }
    else if (isset($result)) {
      $return[] = $result;
    }
  }
  return $return;
}

function migrate_save_content_set(&$content_set) {
  if (is_array($content_set)) {
    $was_array = TRUE;
    $content_set = (object) $content_set;
  } else {
    $was_array = FALSE;
  }
  
  if ($content_set->mcsid) {
    drupal_write_record('migrate_content_sets', $content_set, 'mcsid');
  } else {
    drupal_write_record('migrate_content_sets', $content_set);
  }

  // Create a map table from this view to the results
  $maptablename = _migrate_map_table_name($content_set->view_name, $content_set->contenttype);

  // Get the proper field definition for the sourcekey
  $view = views_get_view($content_set->view_name);
  // Must do this to load the database
  $view->init_query();

  // TODO: For now, PK must be in base_table
  $tabledb = $view->base_database;
  $tablename = $view->base_table;
  db_set_active($tabledb);
  $inspect = schema_invoke('inspect');
  db_set_active('default');
  $sourceschema = $inspect[$tablename];
  // If the PK of the content set is defined, make sure we have a mapping table
  if ($content_set->sourcekey) {
    $sourcefield = $sourceschema['fields'][$content_set->sourcekey];
    if (!db_table_exists($maptablename)) {
      $schema = array(
        'description' => t('Mappings from source key to destination key'),
        'fields' => array(
          $content_set->sourcekey => $sourcefield,
          // @TODO: Assumes destination key is unsigned int
          $content_set->contenttype.'id' => array(
            'type' => 'int',
            'unsigned' => TRUE,
            'not null' => TRUE,
          ),
          'mcsid' => array(
            'type' => 'int',
            'unsigned' => TRUE,
            'not null' => TRUE,
          ),
        ),
        'primary key' => array($content_set->sourcekey),
         'indexes' => array(
           'idkey' => array($content_set->contenttype.'id'),
          ),
        );
      db_create_table($ret, $maptablename, $schema);
      // Expose map table to views
      tw_add_tables(array($maptablename));
      tw_add_fk($maptablename, $content_set->contenttype.'id');
    } else {
      // TODO: Handle change in PK - rebuild map table
    }
  }
  
  if ($was_array) {
    $content_set = (array)$content_set;
    return $content_set['mcsid'];
  } else {
    return $content_set->mcsid;
  }
}

function migrate_save_content_mapping(&$mapping) {
  if ($mapping->mcmid) {
    drupal_write_record('migrate_content_mappings', $mapping, 'mcmid');
  } else {
    drupal_write_record('migrate_content_mappings', $mapping);
  }
}

function migrate_delete_content_set($mcsid) {
  $sql = "DELETE FROM {migrate_content_mappings} WHERE mcsid=%d";
  db_query($sql, $mcsid);
  $sql = "DELETE FROM {migrate_content_sets} WHERE mcsid=%d";
  db_query($sql, $mcsid);
}

/**
 * Convenience function for generating a message array
 *
 * @param text $message - Text describing the error condition
 * @param enum $type - One of the MIGRATE_MESSAGE constants, identifying the level of error
 * @return Structured array suitable for return from a destination hook
 */
function migrate_message($message, $type = MIGRATE_MESSAGE_ERROR) {
  $error = array(
    'level' => $type,
    'message' => $message,
  );
  return $error;
}

/*
 * Implementation of hook_init()
 */
function migrate_init() {
    // Add main CSS functionality.
  drupal_add_css(drupal_get_path('module', 'migrate') .'/migrate.css');
}

/**
 * Implementation of hook_cron()
 *
 */
function migrate_cron() {
  $path = drupal_get_path('module', 'migrate') . '/migrate_pages.inc';
  include_once($path);
  // Elevate privileges so node deletion/creation works in cron
  global $user;
  $saveuser = $user;
  $user = user_load(array('uid' => 1));
  migrate_content_process(variable_get('cron_semaphore', 0));
  $user = $saveuser;
}

/**
 * Implementation of hook_perm().
 */
function migrate_perm() {
  return array(MIGRATE_ACCESS_BASIC, MIGRATE_ACCESS_ADVANCED);  
}

/**
 * Implementation of hook_help().
 */
function migrate_help($page, $arg) {
  switch ($page) {
    case 'admin/help#migrate':
      $output = '<p>'. t('The migrate module aids in the importing of data into your site from
        comma separated values format (CSV) or tab separated values format (TSV) files.') .'</p>';
      $output .= '<p>'. t('Migrate accepts a CSV or TSV file as input. CSV or TSV files can be generated 
        using spreadsheet programs. Your CSV or TSV file must contain field names in its first row. These 
        field names can be anything. Modules, such as contact_manager, will add additional import types.') .'</p>';
      $output .= t('<p>You can</p>
<ul>
<li>read about the PHP function that reads CSV files: 
  <a href="@external-http-us3-php-net-fgetcvs" title="fgetcsv programmer function page">fgetcsv</a>.</li>
<li>import files at <a href="@admin-node-migrate">administer &gt;&gt; content &gt;&gt; migrate</a>.</li>
<li>administer node permissions at <a href="@admin-access-permission">administer &gt;&gt; access &gt;&gt; 
  permissions &gt;&gt; node import</a>.</li>
</ul>', array('@external-http-us3-php-net-fgetcvs' => 'http://us3.php.net/fgetcsv', 
              '@admin-node-migrate' => url('admin/content/tw'), 
              '@admin-access-permission' => url('admin/user/permissions')));
      return $output;
  }
}

/**
 * Implementation of hook_menu().
 */
function migrate_menu() {
  $items = array();

  $items['admin/content/migrate'] = array(
    'title' => 'Migrate',
    'description' => 'Manage data migration from external sources',
    'page callback' => 'migrate_front',
    'access arguments' => array(MIGRATE_ACCESS_BASIC),
    'file' => 'migrate_pages.inc',
  );
  $items['admin/content/migrate/destinations'] = array(
    'title' => 'Content sets',
    'description' => 'Manage content sets: mappings of source data to Drupal content',
    'weight' => 2,
    'page callback' => 'migrate_destinations',
    'access arguments' => array(MIGRATE_ACCESS_ADVANCED),
    'file' => 'migrate_pages.inc',
  );
  $items['admin/content/migrate/process'] = array(
    'title' => 'Process',
    'description' => 'Perform and monitor the creation of Drupal content from source data',
    'weight' => 3,
    'page callback' => 'migrate_dashboard',
    'access arguments' => array(MIGRATE_ACCESS_BASIC),
    'file' => 'migrate_pages.inc',
  );
  $items['admin/content/migrate/tools'] = array(
    'title' => 'Tools',
    'description' => 'Additional tools for managing migration',
    'weight' => 4,
    'page callback' => 'migrate_tools',
    'access arguments' => array(MIGRATE_ACCESS_ADVANCED),
    'file' => 'migrate_pages.inc',
  );
  $items['admin/content/migrate/settings'] = array(
    'title' => 'Settings',
    'description' => 'Migrate module settings',
    'weight' => 5,
    'page callback' => 'migrate_settings',
    'access arguments' => array(MIGRATE_ACCESS_ADVANCED),
    'file' => 'migrate_pages.inc',
  );
  $items['admin/content/migrate/destinations/%'] = array(
    'title' => 'Content set',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('migrate_destination_mappings', 4),
    'access arguments' => array(MIGRATE_ACCESS_ADVANCED),
    'type' => MENU_CALLBACK,
    'file' => 'migrate_pages.inc',
  );
  $items['migrate/xlat/%'] = array(
    'page callback' => 'migrate_xlat',
    'access arguments' => array('access content'),
    'page arguments' => array(2),
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/*
 * Translate URIs from an old site to the new one
 * Requires adding RewriteRules to .htaccess. For example, if the URLs
 * for news articles had the form 
 * http://example.com/issues/news/[OldID].html, use this rule:
 * 
 * RewriteRule ^issues/news/([0-9]+).html$ /migrate/xlat/node/$1 [L]
 */
function migrate_xlat($contenttype=NULL, $oldid=NULL) {
  $uri = '';
  if ($contenttype && $oldid) {
    $newid = _migrate_xlat_get_new_id($contenttype, $oldid);
    if ($newid) {
      $uri = migrate_invoke_all('destination', 'xlat', $contenttype, $newid);
      drupal_goto($uri[0], NULL, NULL, 301);
    }
  }
}

/*
 * Helper function to translate an ID from a source file to the corresponding
 * Drupal-side ID (nid, uid, etc.)
 * 
 * TODO: Update to new world (content sets as the basis of migration)
 */
function _migrate_xlat_get_new_id($contenttype, $oldid) {
  $result = db_query("SELECT DISTINCT mf.importtable, mc.colname
                      FROM {migrate_content_sets} mcs
                      INNER JOIN {migrate_files} mf ON mcs.mfid=mf.mfid
                      INNER JOIN {migrate_columns} mc ON mf.mfid=mc.mfid AND chosenpk=1
                      WHERE mcs.contenttype='%s'",
                     $contenttype);
  while ($row = db_fetch_object($result)) {
    $table = $row->importtable.'_'.$contenttype.'map';
    $pkcol = $row->colname;
    $id = db_result(db_query("SELECT ${contenttype}id
                              FROM {$table} WHERE $pkcol=%d", $oldid));
    if ($id) {
      return $id;
    }
  }
  return NULL;
}

/**
 * Implementation of hook_theme().
 *
 * Registers all theme functions used in this module.
 */
function migrate_theme() {
  return array(
    'migrate_mapping_table' => array('arguments' => array('form')),
    '_migrate_dashboard_form' => array(
      'arguments' => array('form' => NULL),
      'function' => 'theme_migrate_dashboard',
    ),
    '_migrate_tools_form' => array(
      'arguments' => array('form' => NULL),
      'function' => 'theme_migrate_tools',
    ),
    '_migrate_settings_form' => array(
      'arguments' => array('form' => NULL),
      'function' => 'theme_migrate_settings',
    ),
    'migrate_destination_mappings' => array(
      'arguments' => array('form' => NULL),
      'function' => 'theme_migrate_destination_mappings',
    ),
  );
}

function _migrate_message_table_name($view_name, $contenttype) {
  return $view_name . '_' . $contenttype . '_msgs';
}

function _migrate_map_table_name($view_name, $contenttype) {
  return $view_name . '_' . $contenttype . '_map';
}

function migrate_views_api() {
  return array('api' => '2.0');
}
