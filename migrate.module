<?php

define('MIGRATE_API_VERSION', 1);

define('MIGRATE_ACCESS_BASIC', 'basic migration tools');
define('MIGRATE_ACCESS_ADVANCED', 'advanced migration tools');

define('MIGRATE_MESSAGE_ERROR', 1);
define('MIGRATE_MESSAGE_WARNING', 2);
define('MIGRATE_MESSAGE_NOTICE', 3);
define('MIGRATE_MESSAGE_INFORMATIONAL', 4);

define('MIGRATE_STATUS_IDLE', 0);
define('MIGRATE_STATUS_IMPORTING', 1);
define('MIGRATE_STATUS_CLEARING', 2);

define('MIGRATE_RESULT_COMPLETED', 1);
define('MIGRATE_RESULT_INCOMPLETE', 2);
define('MIGRATE_RESULT_STOPPED', 3);
define('MIGRATE_RESULT_FAILED', 4);
define('MIGRATE_RESULT_IN_PROGRESS', 5);

define('MIGRATE_MEMORY_THRESHOLD', .8);


// Get all content sets.
function migrate_content_sets($refresh = FALSE) {
  static $sets = array();

  if (isset($sets) || $refresh) {
    foreach (module_implements('content_set_info') as $module) {
      if ($items = module_invoke($module, 'content_set_info')) {
        foreach ($items as $machine_name => $item) {
          // Add module element.
          $item['module'] = $module;
          $item['machine_name'] = $machine_name;
          if (isset($item['file'])) {
            $file_path = isset($item['file path']) ? $item['file path'] : drupal_get_path('module', $module);
            $item['include file'] = $file_path . '/' . $item['file'];
          }
        }
        $sets[$machine_name] = $item;
      }
    }
  }
  return $sets;
}

function migrate_load_include($set) {
  if (isset($set['include file'])) {
    require_once DRUPAL_ROOT . '/' . $set['include file'];
  }
}

function migrate_map_table_name($set) {
  return 'migrate_map_' . $set['machine_name'];
}

function migrate_message_table_name($set) {
  return 'migrate_message_' . $set['machine_name'];
}

function migrate_rehash() {
  $sets = migrate_content_sets();
  foreach ($sets as $set) {
    $name = migrate_map_table_name($set);
    if (!db_table_exists($name)) {
      $schema = _migrate_map_table_schema($set['sourcefield']);
      // var_dump($schema);die();
      db_create_table($name, $schema);
    }
    $name = migrate_message_table_name($set);
    if (!db_table_exists($name)) {
      $schema = _migrate_message_table_schema($set['sourcefield']);
      db_create_table($name, $schema);
    }
  }
}

/**
 * Call a migrate hook. Like module_invoke_all, but gives modules a chance
 * to do one-time initialization before any of their hooks are called, and
 * adds "migrate" to the hook name.
 * @param $hook
 *  Hook to invoke (e.g., 'types', 'fields_node', etc.)
 * @return
 *  Merged array of results.
 */
function migrate_invoke_all($hook) {
  // Let modules do any one-time initialization (e.g., including migration support files)
  global $_migrate_inited;
  if (!isset($_migrate_inited)) {
    module_invoke_all('migrate_init');
    $_migrate_inited = TRUE;
  }

  $args = func_get_args();
  $hookfunc = "migrate" . "_$hook";
  unset($args[0]);
  $return = array();
  $modulelist = module_implements($hookfunc);
  foreach ($modulelist as $module) {
    $function = $module . '_' . $hookfunc;
    $result = call_user_func_array($function, $args);
    if (isset($result) && is_array($result)) {
      $return = array_merge_recursive($return, $result);
    }
    elseif (isset($result)) {
      $return[] = $result;
    }
  }
  return $return;
}

/**
 * Generate a message table schema record, given the source PK definition
 * @param $sourcefield
 *  Schema definition for the content set source's PK
 * @return
 *  Schema structure for a message table
 */
function _migrate_message_table_schema($sourcefield) {
  $schema = array(
    'description' => t('Import errors'),
    'fields' => array(
      'mceid' => array(
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'sourceid' => $sourcefield,
      'level' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
         'default' => 1,
      ),
      'message' => array(
        'type' => 'text',
        'size' => 'medium',
        'not null' => TRUE,
      ),
    ),
    'primary key' => array('mceid'),
    'indexes' => array(
      'sourceid' => array('sourceid'),
    ),
  );
  return $schema;
}

/**
 * Generate a map table schema record, given the source PK definition
 * @param $sourcefield
 *  Schema definition for the content set source's PK
 * @return
 *  Schema structure for a map table
 */
function _migrate_map_table_schema($sourcefield) {
  $schema = array(
    'description' => t('Mappings from source key to destination key'),
    'fields' => array(
      'sourceid' => $sourcefield,
      // @TODO: Assumes destination key is unsigned int
      'destid' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'needs_update' => array(
        'type' => 'int',
        'size' => 'tiny',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => (int)FALSE,
      ),
    ),
    'primary key' => array('sourceid'),
    'indexes' => array(
      'idkey' => array('destid'),
    ),
  );
  return $schema;
}






