<?php 
// $Id$

define('MIGRATE_ACCESS_BASIC', 'basic migration tools');
define('MIGRATE_ACCESS_ADVANCED', 'advanced migration tools');

define('MIGRATE_MESSAGE_ERROR', 1);
define('MIGRATE_MESSAGE_WARNING', 2);
define('MIGRATE_MESSAGE_NOTICE', 3);
define('MIGRATE_MESSAGE_INFORMATIONAL', 4);

/**
 * @file
 * This module provides tools at "administer >> content >> migrate"
 * for analyzing data from various sources and importing them into Drupal tables.
 * 
 * @TODO:
 * PostGres support (MySQL is assumed in several places)
 * Robustness - check to make sure all prerequisites are done (e.g., table view should
 *  not be available until Analyze is done)
 * The analysis tool allows setting a multi-column PK for the import file, but everything
 *  else assumes a single column. Dealing with this is deferred until/unless we have a 
 *  situation requiring a multi-column PK.
 */

/**
 * Call a migrate hook
 */
function migrate_invoke_all($kind, $hook, $type = NULL) {
  // Let modules do any one-time initialization (e.g., including migration support files)
  module_invoke_all('migrate_init');
  $args = func_get_args();
  $hookfunc = "migrate_$kind"."_$hook";
  if (isset($type)) {
    $hookfunc .= "_$type";
    unset($args[2]);
  }
  unset($args[1]);
  unset($args[0]);
  $return = array();
  $modulelist = module_implements($hookfunc);
  foreach ($modulelist as $module) {
    $function = $module .'_'. $hookfunc;
    $result = call_user_func_array($function, $args);
    if (isset($result) && is_array($result)) {
      $return = array_merge_recursive($return, $result);
    }
    else if (isset($result)) {
      $return[] = $result;
    }
  }
  return $return;
}

/**
 * Save a new or updated content set
 *
 * @param $content_set
 *  An array or object representing the content set. This is passed by reference (so
 *  when adding a new content set the ID can be set)
 * @param $options
 *  Array of additional options for saving the content set. Currently:
 *    base_table: The base table of the view - if provided, we don't need
 *                to load the view.
 *    base_database: The database of the base table - if base_table is present
 *                and base_database omitted, it defaults to 'default'
 * @return 
 *  The ID of the content set that was saved
 */
function migrate_save_content_set(&$content_set, $options = array()) {
  // Deal with objects internally (but remember if we need to put the parameter
  // back to an array)
  if (is_array($content_set)) {
    $was_array = TRUE;
    $content_set = (object) $content_set;
  } else {
    $was_array = FALSE;
  }

  // Update or insert the content set record as appropriate
  if ($content_set->mcsid) {
    drupal_write_record('migrate_content_sets', $content_set, 'mcsid');
  } else {
    drupal_write_record('migrate_content_sets', $content_set);
  }

  // Create or modify map and message tables
  $maptablename = _migrate_map_table_name($content_set->view_name);
  $msgtablename = _migrate_message_table_name($content_set->view_name);
  
  // TODO: For now, PK must be in base_table
  
  // If the caller tells us the base table of the view, we don't need
  // to load the view (which would not work when called from hook_install())
  if (isset($options['base_table'])) {
    $tablename = $options['base_table'];
    if (isset($options['base_database'])) {
      $tabledb = $options['base_database'];
    }
    else {
      $tabledb = 'default';
    }
  }
  else {
    // Get the proper field definition for the sourcekey
    $view = views_get_view($content_set->view_name);
    // Must do this to load the database
    $view->init_query();

    $tabledb = $view->base_database;
    $tablename = $view->base_table;
  }

  db_set_active($tabledb);
  $inspect = schema_invoke('inspect');
  db_set_active('default');
  $sourceschema = $inspect[$tablename];
  // If the PK of the content set is defined, make sure we have a mapping table
  if ($content_set->sourcekey) {
    $sourcefield = $sourceschema['fields'][$content_set->sourcekey];
    // The field name might be <table>_<column>...
    if (!$sourcefield) {
      $sourcekey = substr($content_set->sourcekey, strlen($tablename) + 1);
      $sourcefield = $sourceschema['fields'][$sourcekey];
    }
    // But - we don't want serial fields to behave serially, so change to int
    if ($sourcefield['type'] == 'serial') {
      $sourcefield['type'] = 'int';
    }

    if (!db_table_exists($maptablename)) {
      $schema = _migrate_map_table_schema($sourcefield);
      db_create_table($ret, $maptablename, $schema);
      // Expose map table to views
      tw_add_tables(array($maptablename));
      tw_add_fk($maptablename, 'destid');

      $schema = _migrate_message_table_schema($sourcefield);
      db_create_table($ret, $msgtablename, $schema);
      // Expose messages table to views
      tw_add_tables(array($msgtablename));
      tw_add_fk($msgtablename, 'sourceid');
    } else {
      // TODO: Deal with varchar->int case where there is existing non-int data
      $desired_schema = _migrate_map_table_schema($sourcefield);
      $actual_schema = $inspect[$maptablename];
      if ($desired_schema['fields']['sourceid'] != $actual_schema['fields']['sourceid']) {
        $ret = array();
        db_drop_primary_key($ret, $maptablename);
        db_change_field($ret, $maptablename, 'sourceid', 'sourceid', 
          $sourcefield, array('primary key' => array('sourceid')));
      }
      $desired_schema = _migrate_message_table_schema($sourcefield);
      $actual_schema = $inspect[$msgtablename];
      if ($desired_schema['fields']['sourceid'] != $actual_schema['fields']['sourceid']) {
        $ret = array();
        db_drop_index($ret, $msgtablename, 'sourceid');
        db_change_field($ret, $msgtablename, 'sourceid', 'sourceid', 
          $sourcefield, array('indexes' => array('sourceid' => array('sourceid'))));
      }
    }
  }

  if ($was_array) {
    $content_set = (array)$content_set;
    return $content_set['mcsid'];
  } else {
    return $content_set->mcsid;
  }
}

function migrate_save_content_mapping(&$mapping) {
  if ($mapping->mcmid) {
    drupal_write_record('migrate_content_mappings', $mapping, 'mcmid');
  } else {
    drupal_write_record('migrate_content_mappings', $mapping);
  } 
}

function migrate_delete_content_set($mcsid) {
  // First, remove the map and message tables from the Table Wizard, and drop them
  $ret = array();
  $sql = "SELECT view_name FROM {migrate_content_sets} WHERE mcsid=%d";
  $view_name = db_result(db_query($sql, $mcsid));
  $maptable = _migrate_map_table_name($view_name);
  $msgtable = _migrate_message_table_name($view_name);
  tw_remove_tables(array($maptable, $msgtable));
  db_drop_table($ret, $maptable);
  db_drop_table($ret, $msgtable);
  
  // Then, delete the content set data
  $sql = "DELETE FROM {migrate_content_mappings} WHERE mcsid=%d";
  db_query($sql, $mcsid);
  $sql = "DELETE FROM {migrate_content_sets} WHERE mcsid=%d";
  db_query($sql, $mcsid);
}

function migrate_delete_content_mapping($mcmid) {
  $sql = "DELETE FROM {migrate_content_mappings} WHERE mcmid=%d";
  db_query($sql, $mcmid);
}

/**
 * Convenience function for generating a message array
 *
 * @param $message
 *  Text describing the error condition
 * @param $type
 *  One of the MIGRATE_MESSAGE constants, identifying the level of error
 * @return 
 *  Structured array suitable for return from a destination hook
 */
function migrate_message($message, $type = MIGRATE_MESSAGE_ERROR) {
  $error = array(
    'level' => $type,
    'message' => $message,
  );
  return $error;
}

/**
 * Add a mapping from source ID to destination ID for the specified content set
 *
 * @param $mcsid
 *  ID of the content set being processed
 * @param $sourceid
 *  Primary key value from the source
 * @param $destid
 *  Primary key value from the destination
 */
function migrate_add_mapping($mcsid, $sourceid, $destid) {
  static $maptables = array();
  if (!isset($maptables[$mcsid])) {
    $sql = "SELECT view_name FROM {migrate_content_sets} WHERE mcsid=%d";
    $view_name = db_result(db_query($sql, $mcsid));
    $maptables[$mcsid] = _migrate_map_table_name($view_name);
  }
  $mapping = new stdClass;
  $mapping->sourceid = $sourceid;
  $mapping->destid = $destid;
  drupal_write_record($maptables[$mcsid], $mapping);
}

/*
 * Implementation of hook_init()
 */
function migrate_init() {
  $path = drupal_get_path('module', 'migrate') . '/migrate_destinations.inc';
  include_once($path);
  
    // Add main CSS functionality.
  drupal_add_css(drupal_get_path('module', 'migrate') .'/migrate.css');
}

/**
 * Implementation of hook_cron()
 *
 */
function migrate_cron() {
  $path = drupal_get_path('module', 'migrate') . '/migrate_pages.inc';
  include_once($path);
  // Elevate privileges so node deletion/creation works in cron
  global $user;
  $saveuser = $user;
  $user = user_load(array('uid' => 1));
  migrate_content_process(variable_get('cron_semaphore', 0));
  $user = $saveuser;
}

/**
 * Implementation of hook_perm().
 */
function migrate_perm() {
  return array(MIGRATE_ACCESS_BASIC, MIGRATE_ACCESS_ADVANCED);  
}

/**
 * Implementation of hook_help().
 */
function migrate_help($page, $arg) {
  switch ($page) {
    case 'admin/help#migrate':
      $output = '<p>'. t('The migrate module aids in the importing of data into your site from
        comma separated values format (CSV) or tab separated values format (TSV) files.') .'</p>';
      $output .= '<p>'. t('Migrate accepts a CSV or TSV file as input. CSV or TSV files can be generated 
        using spreadsheet programs. Your CSV or TSV file must contain field names in its first row. These 
        field names can be anything. Modules, such as contact_manager, will add additional import types.') .'</p>';
      $output .= t('<p>You can</p>
<ul>
<li>read about the PHP function that reads CSV files: 
  <a href="@external-http-us3-php-net-fgetcvs" title="fgetcsv programmer function page">fgetcsv</a>.</li>
<li>import files at <a href="@admin-node-migrate">administer &gt;&gt; content &gt;&gt; migrate</a>.</li>
<li>administer node permissions at <a href="@admin-access-permission">administer &gt;&gt; access &gt;&gt; 
  permissions &gt;&gt; node import</a>.</li>
</ul>', array('@external-http-us3-php-net-fgetcvs' => 'http://us3.php.net/fgetcsv', 
              '@admin-node-migrate' => url('admin/content/tw'), 
              '@admin-access-permission' => url('admin/user/permissions')));
      return $output;
  }
}

/**
 * Implementation of hook_menu().
 */
function migrate_menu() {
  $items = array();

  $items['admin/content/migrate'] = array(
    'title' => 'Migrate',
    'description' => 'Manage data migration from external sources',
    'page callback' => 'migrate_front',
    'access arguments' => array(MIGRATE_ACCESS_BASIC),
    'file' => 'migrate_pages.inc',
  );
  $items['admin/content/migrate/destinations'] = array(
    'title' => 'Content sets',
    'description' => 'Manage content sets: mappings of source data to Drupal content',
    'weight' => 2,
    'page callback' => 'migrate_destinations',
    'access arguments' => array(MIGRATE_ACCESS_ADVANCED),
    'file' => 'migrate_pages.inc',
  );
  $items['admin/content/migrate/process'] = array(
    'title' => 'Process',
    'description' => 'Perform and monitor the creation of Drupal content from source data',
    'weight' => 3,
    'page callback' => 'migrate_dashboard',
    'access arguments' => array(MIGRATE_ACCESS_BASIC),
    'file' => 'migrate_pages.inc',
  );
  $items['admin/content/migrate/tools'] = array(
    'title' => 'Tools',
    'description' => 'Additional tools for managing migration',
    'weight' => 4,
    'page callback' => 'migrate_tools',
    'access arguments' => array(MIGRATE_ACCESS_ADVANCED),
    'file' => 'migrate_pages.inc',
  );
  $items['admin/content/migrate/settings'] = array(
    'title' => 'Settings',
    'description' => 'Migrate module settings',
    'weight' => 5,
    'page callback' => 'migrate_settings',
    'access arguments' => array(MIGRATE_ACCESS_ADVANCED),
    'file' => 'migrate_pages.inc',
  );
  $items['admin/content/migrate/destinations/%'] = array(
    'title' => 'Content set',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('migrate_destination_mappings', 4),
    'access arguments' => array(MIGRATE_ACCESS_ADVANCED),
    'type' => MENU_CALLBACK,
    'file' => 'migrate_pages.inc',
  );
  $items['migrate/xlat/%'] = array(
    'page callback' => 'migrate_xlat',
    'access arguments' => array('access content'),
    'page arguments' => array(2),
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Implementation of hook_schema_alter
 * @param $schema
 */
function migrate_schema_alter(&$schema) {
  $result = db_query("SELECT * FROM {migrate_content_sets}");
  while ($content_set = db_fetch_object($result)) {
    $maptablename = _migrate_map_table_name($content_set->view_name);
    $msgtablename = _migrate_message_table_name($content_set->view_name);

    // Get the proper field definition for the sourcekey
    $view = views_get_view($content_set->view_name);
    // Must do this to load the database
    $view->init_query();

    // TODO: For now, PK must be in base_table
    $tabledb = $view->base_database;
    $tablename = $view->base_table;
    db_set_active($tabledb);
    $inspect = schema_invoke('inspect');
    db_set_active('default');
    $sourceschema = $inspect[$tablename];
    // If the PK of the content set is defined, make sure we have a mapping table
    if ($content_set->sourcekey) {
      $sourcefield = $sourceschema['fields'][$content_set->sourcekey];
      // We don't want serial fields to behave serially, so change to int
      if ($sourcefield['type'] == 'serial') {
        $sourcefield['type'] = 'int';
      }
      $schema[$maptablename] = _migrate_map_table_schema($sourcefield);
      $schema[$msgtablename] = _migrate_message_table_schema($sourcefield);
    }
  }
}

/*
 * Translate URIs from an old site to the new one
 * Requires adding RewriteRules to .htaccess. For example, if the URLs
 * for news articles had the form 
 * http://example.com/issues/news/[OldID].html, use this rule:
 * 
 * RewriteRule ^issues/news/([0-9]+).html$ /migrate/xlat/node/$1 [L]
 */
function migrate_xlat($contenttype=NULL, $oldid=NULL) {
  $uri = '';
  if ($contenttype && $oldid) {
    $newid = _migrate_xlat_get_new_id($contenttype, $oldid);
    if ($newid) {
      $uri = migrate_invoke_all('destination', 'xlat', $contenttype, $newid);
      drupal_goto($uri[0], NULL, NULL, 301);
    }
  }
}

/*
 * Helper function to translate an ID from a source file to the corresponding
 * Drupal-side ID (nid, uid, etc.)
 * 
 * TODO: Update to new world (content sets as the basis of migration)
 */
function _migrate_xlat_get_new_id($contenttype, $oldid) {
  $result = db_query("SELECT DISTINCT mf.importtable, mc.colname
                      FROM {migrate_content_sets} mcs
                      INNER JOIN {migrate_files} mf ON mcs.mfid=mf.mfid
                      INNER JOIN {migrate_columns} mc ON mf.mfid=mc.mfid AND chosenpk=1
                      WHERE mcs.contenttype='%s'",
                     $contenttype);
  while ($row = db_fetch_object($result)) {
    $table = _migrate_map_table_name($row->importtable);
    $pkcol = $row->colname;
    $id = db_result(db_query("SELECT destid
                              FROM {$table} WHERE sourceid=%d", $oldid));
    if ($id) {
      return $id;
    }
  }
  return NULL;
}

/**
 * Implementation of hook_theme().
 *
 * Registers all theme functions used in this module.
 */
function migrate_theme() {
  return array(
    'migrate_mapping_table' => array('arguments' => array('form')),
    '_migrate_dashboard_form' => array(
      'arguments' => array('form' => NULL),
      'function' => 'theme_migrate_dashboard',
    ),
    '_migrate_tools_form' => array(
      'arguments' => array('form' => NULL),
      'function' => 'theme_migrate_tools',
    ),
    '_migrate_settings_form' => array(
      'arguments' => array('form' => NULL),
      'function' => 'theme_migrate_settings',
    ),
    'migrate_destination_mappings' => array(
      'arguments' => array('form' => NULL),
      'function' => 'theme_migrate_destination_mappings',
    ),
  );
}

function _migrate_map_table_name($view_name) {
  return $view_name . '_map';
}

function _migrate_message_table_name($view_name) {
  return $view_name . '_msgs';
}

function _migrate_map_table_schema($sourcefield) {
  $schema = array(
    'description' => t('Mappings from source key to destination key'),
    'fields' => array(
      'sourceid' => $sourcefield,
      // @TODO: Assumes destination key is unsigned int
      'destid' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
    ),
    'primary key' => array('sourceid'),
    'indexes' => array(
      'idkey' => array('destid'),
    ),
  );
  return $schema;
}

function _migrate_message_table_schema($sourcefield) {
  $schema = array(
    'description' => t('Import errors'),
    'fields' => array(
      'mceid' => array(
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'sourceid' => $sourcefield,
      'level' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
         'default' => 1,
      ),
      'message' => array(
        'type' => 'text',
        'size' => 'medium',
        'not null' => TRUE,
      ),
    ),
    'primary key' => array('mceid'),
    'indexes' => array(
      'sourceid' => array('sourceid'),
    ),
  );
  return $schema;
}

function migrate_views_api() {
  return array('api' => '2.0');
}
