<!-- $Id$ -->

<h2 id="destinationtypes">Destination types</h2> 
 
<p>The migrate module supports the definition of different destination types - kinds of objects to be created in a migration. There is built-in support for nodes, users, comments, roles, and taxonomy terms - hooks can be defined for additional destination types.</p> 
 
<p>Here are the steps we took to create the Role destination type. Your destination types will follow a similar pattern.</p> 
 
<ul> 
<li><p>Implement hook_migrate_destination_types(), returning an array mapped from the internal name of the type (used to build hook names, in particular) to the user-visible type name:</p> 
 
<p><pre>function user_migrate_destination_types() {
  $types = array('user' =&gt; t('User'), 'role' =&gt; t('Role'));
  return $types;
}</pre></p></li> 
<li><p>Implement hook_migrate_destination_fields_<type>, returning an array mapped from the internal field name (within Drupal) to the user-visible name:</p> 
 
<p><pre>function user_migrate_destination_fields_role($type) {
  $fields = array(
    'name' =&gt; t('Role name'),
  );
  return $fields;
}</pre></p></li> 
<li><p>Implement hook_migrate_destination_delete_<type>, which takes the unique identifier of the destination object on the Drupal side and deletes that object and everything that depends on that object:</p> 
 
<p><pre>function user_migrate_destination_delete_role($rid) {
  db_query('DELETE FROM {users_roles} WHERE rid = %d', $rid);
  db_query('DELETE FROM {permission} WHERE rid = %d', $rid);
  db_query('DELETE FROM {role} WHERE rid = %d', $rid);
}</pre></p></li> 
<li><p>Now, here&#8217;s the major work: implement hook_migrate_destination_import_<type> :</p> 
 
<p><pre>
function user_migrate_destination_import_role($tblinfo, $row) {
  $errors = array();
  $newrole = array();
  // For each destination field, populate it with the source value if present, and if
  // if not use the specified default value
  foreach ($tblinfo-&gt;fields as $destfield =&gt; $values) {
    if ($values['srcfield'] &amp;&amp; isset($row-&gt;$values['srcfield'])) {
      $newvalue = $row-&gt;$values['srcfield'];
    } else {
      $newvalue = $values['default_value'];
    }
    $newrole[$destfield] = $newvalue;
  }
  $role_name = $newrole['name'];
  if ($role_name) {
    db_query("INSERT INTO {role} (name) VALUES ('%s')", $role_name);
    $sql = "SELECT * FROM {role} WHERE name='%s'";
    $role = db_fetch_object(db_query($sql, $role_name));
    // Call completion hooks, for any additional role-related processing
    // (such as assigning permissions)
    timer_start('role completion hooks');
    $errors = migrate_destination_invoke_all('complete_role', $role, $tblinfo, $row);
    timer_stop('role completion hooks');
    // Fill in the map table, so the migrate module knows this row is done
    $sourcekey = $tblinfo-&gt;sourcekey;
    migrate_add_mapping($tblinfo-&gt;mcsid, $row-&gt;$sourcekey, $role-&gt;rid);
  }
  return $errors;
}</pre></p></li> 
</ul> 
 
<p>$tblinfo contains the meta-information on the content set, and $row is the source data for one object. An array of messages is returned - use migrate_message() to generate a message. </p> 
 
<h2 id="contentsets">Content sets</h2> 
 
<p>A content set defines the migration from a set of source data (implemented as a view) into a given destination type. Content sets can be defined interactively or programmatically. The typical process to create a content set programmatically would be as follows:</p> 
 
<ul> 
<li><p>Add an update function to the .install file for a custom module (this document calls it ec_migrate.install). In the update function, first add any source tables to the Table Wizard. Pass TRUE to prevent immediate full analysis of the table (otherwise, for large tables, the update function risks timing out).</p> 
 
<p><pre>tw_add_tables('role_o', TRUE);</pre></p></li> 
<li><p>If these tables need to relate to other tables, add FK flags to any columns used in joins, and add the relationships:</p> 
 
<p><pre>TBD</pre></p></li> 
<li><p>If the content set is based only on a single source table with a single primary key, and requires no filtering, the default view instantiated by the Table Wizard for that table can be used in the content set. Otherwise, you need to define a view containing all the necessary data as a default view (create the view interactively, export, and paste the code into ec_migrate.views_default.inc). Naming convention is <destination><em>content</em>set (e.g., role_content_set).</p></li> 
<li><p>Create the content set in your update function, by building the object and saving it:</p> 
 
<p><pre>$content_set = new stdClass;
$content_set-&gt;view_name = 'role_content_set';
$content_set-&gt;sourcekey = 'role_id';
$content_set-&gt;contenttype = 'role';
$content_set-&gt;description = 'Roles';
$content_set-&gt;weight = 9;
migrate_save_content_set($content_set, array('base_table' =&gt; 'role_o'));
$mcsid = $content_set-&gt;mcsid;</pre></p> 
 
<p>For each field to automatically be copied from a source field to a destination field, build a mapping object and save it:</p> 
 
<p><pre>$mapping = new stdClass;
$mapping-&gt;mcsid = $mcsid;
$mapping-&gt;srcfield = 'role_o_role_name';
$mapping-&gt;destfield = 'name';
migrate_save_content_mapping($mapping);</pre></p></li> 
<li><p>Usually, simply copying source fields to destination fields are not enough - you need to implement a hook to perform further manipulations. A destination type may support a prepare hook (called for each object after the automatic mappings are applied but before the destination is saved) and/or a complete hook (called after the destination is saved). The standard signature is:</p> 
 
<p><pre>function ec_migrate_migrate_destination_prepare_user(&amp;$account, $tblinfo, $row)</pre></p> 
 
<p>$account - The destination object (in this case, a user account object)
$tblinfo - Information on the content set itself
$row - The source data</p></li> 
</ul>